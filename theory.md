# Краткий гайд по ассемблеру

## Предисловие
Все написанное ниже праведливо для GNU Assembler (x86_64).  
Код пишем в расширении `.s`, ассемблерный файл program.s под Ubuntu 22.04 скомпилировать можно так:
```
g++ -s program.s
```
Создастся дефолтный исполняемый файл `a.out`.

## Секции программы и типы данных
В общем случае всё, чем мы располагаем - это регистры и глобальные переменные.  

Секции нам нужны будут следующие:
* `rodata` - здесь хранятся глобальные константы, т.е. переменные, не изменяемые в ходе выполнения программы
* `data` - просто статические глобальные переменные (а других-то и нет...)
* `text` - секция, в которой находится сам выполняемый код.  

Основные типы данных:
* `.byte` - один байт (аналог сишного char)
* `.word` - два байта (аналог сишного short)
* `.long` - четыре байта (аналог сишного int)
* `.quad` - восемь байт (аналог сишного int64_t или long long)
* `.string` - нуль-терминированная строка
* `.space` - то же, что и `byte`, но в контексте массивов (для лучшего понимания см. пример ниже)  

Пример простенькой программы с объявлением переменных:
```
section .rodata
    
hello_world:
    .string "Hello, world!" // константа типа string

int_max_value:
    .long 2147483647 // константа типа long (2**31 - 1)

section .data

my_non_const_number:
    .long 0 // в начале выполнения будет равным 0

long_long_value:
    .quad 0 // long long, инициализированный нулём

my_buffer:
    .space 200, 0 // эквивалентно сишному "char my_buffer[200]", все значения равны нулю
    
.section text
.globl  main
.type   main, @function

main:
    // Наш код
```

## Регистры
Регистры - ячейки памяти, расположенные прямо на нашем кремниевом товарище - CPU. Еще их называют *сверхбыстрой оперативной памятью* - доступ к регистрам многократно быстрее, чем доступ к рандомному участку RAM.  

Регистры, которые мы будем использовать в "повседневной" жизни, называются регистрами общего пользования. Их всего 14 штук:  
* `%rax` - *основной* регистр: в него записывают номера системных вызовов, в нём же функции возвращают значения (от **a**ccumulate)
* `%rbx`- регистр, в котором чаще всего хранят адрес начала массивов, используемых где-то в циклах (от **b**ase)
* `%rcx` - регистр, часто используемый в качестве счётчика в цикле (**c**ounter)
* `%rdx, %rdi, %rsi` - основные регистры для передачи аргументов в функции
* `%r8, %r9, %r10, %r11, %r12, %r13, %r14, %r15` - второстепенные регистры для передачи аргументов в функции.

В пояснении к каждой группе указано просто некоторое специфическое значение, присущее этой группе регистров и являющееся некоторым неформальным соглашением среди asm enjoyer'ов - вам никто не мешает использовать любой из них в своих целях.

Особое положение занимают регистры `%rsp` и `%rip` - о них еще поговорим.  
Если вы шокированы количеством регистров, не пугайтесь - `%r8` - `%r15` использовать на самом деле не придётся, так что все не так уж и плохо.  

Все вышеперечисленные регистры имеют размер 64 бита, но в большинстве из них есть возможность обращаться к младшим 32, 16 и 8 битам:  
<image src="https://disk.yandex.ru/i/63HIsnL9HzkUyw" alt="Таблица регистров">


## Операции

Все бинарные операции имеют вид `%имя_операции% %источник% %приёмник%` (характерно для синтаксиса AT&T, в интеловском источник пишется после приёмника).  

**Важно!**  
Источник и приёмник могут быть
* регистром и регистром
* регистром и ячейкой памяти
* ячейкой памяти и регистром
* константой и регистром
* константой и ячейкой памяти,  

но **не могут быть** ячейками памяти одновременно!  
Можно понимать это ограничение так: процессор для выполнения бинарной операции должен обращаться только к одному участку RAM, второй должен быть у него "под боком" (т.е. в регистре).


### Суффиксы операций
Если размеры операндов совпадают - ок.  
Если не совпадают (или операция и вовсе унарная), нужно намекнуть компилятору, с какого размера операндами хочется работать, и сделать это можно, добавив к названию операции соответствующий суффикс:
* b для однобайтных операндов (**byte**)
* w для двухбайтных операндов (**word**)
* l для четырёхбайтных операндов (**long**)
* q для восьмибайтных операндов (**quad**)

Например, когда мы пишем `mov %eax, %ebx`, неоднозначности не возникает - оба регистра четырёхбайтные, но если:
* `mov n(%rip), %rax` - что происходит и сколько байт нужно перемещать в `%rax`? Нужен суффикс.
* `inc n(%rip)` - по какому правилу мы  должны прибавлять к n единицу и как отслеживать переполнения? Без суффикса тоже не очень понятно.

*Эмпирическое правило*: добавляйте такой суффикс **всегда**, так код становится более прозрачным и легче читаемым.
### Операции управления памятью

* `mov src, dest` записывает значение `src` в `dest`. `src` остаётся неизменным (mov - **move**)
```
movq $7, %rbx  // теперь %rbx == 7
movq n(%rip), %rdi // в %rdi лежит 8 байт, начиная с адреса переменной n (если n типа quad, то просто значение n)
```

* `lea src, dest` записывает **адрес** `src` в `dest`. `src` остаётся неизменным (lea - **load effective address**).
```
leaq n(%rip), %rdi // в %rdi лежит адрес переменной n
```

Если хотите обнулить регистр (или просто записать туда константу, перед ней нужно добавить символ `$`, иначе компилятор вас не поймет):  
```
movq $0, %rax // правильно
movq 0, %rax // неправильно
```

### Арифметические операции
#### Унарные
* `inc src` увеличивает значение `src` на 1 (`src` - регистр или память) (inc - **increment**)
* `dec src` уменьшает значение `src` на 1 (`src` - регистр или память) (dec - **decrement**)
* `shl src` осуществляет битовый сдвиг `src` влево на 1 (shl - **shift left**)
* `shr src` осуществляет битовый сдвиг `src` вправо на 1 (shr - **shift right**)

#### Бинарные
Названия тут уже совсем говорящие, поэтому мнемонику пояснять не буду :)
* `add src, dest` добавляет `src` к `dest`
* `sub src, dest` отнимает `src` от `dest` 
* `xor src, dest` ксорит `dest` с `src` (xor - побитовое исключающее или) 
* `mul src, dest` умножает `dest` на `src` (для **беззнаковых** чисел) 
* `imul src, dest` умножает `dest` на `src` (для **знаковых** чисел)

Как и в случае умножения, для беззнакового деления служит **div**, а для знакового - **idiv**.  
Тем не менее, деление в ассемблере выполняется несколько иначе:  

Команда `div src` делает следующее:
1. Смотрит на размер операнда `src`, пусть это k-байтный операнд
2. Берёт соответствующие (k-байтные) части регистров `%rdx`, `%rax`, т.е. (`%rdx`, `%rax`) для k = 8, (`%edx`, `%eax`) для k = 4, (`%dx`, `%ax`) для k = 2 и (`%dl`, `%al`) для k = 1
3. Интерпретируя эти части `%rdx` и `%rax` как **одно число**, старшая половина которого записана в части `%rdx`, а младшая - в части `%rax`, делит это число на `src` и **записывает частное в эту же часть `%rdx`, а остаток - в эту же часть `%rax`**.

`idiv src` действует аналогично, только считает все числа знаковыми.

Без примера, тут, кажется, никуда, поэтому давайте представим, что вам нужно поделить 8-байтное знаковое число. лежащее в `%rbx`, на другое восьмибайтное знаковое число, лежащее в `%rcx`:  
Алгоритм:
1. Переместим делимое в `%rax`
2. "Расширим" восьмибайтное число в `%rax` так, чтобы старшая часть (в т.ч. бит знака) лежала в `%rdx`, а младшая - в `%rax` (специально для этого есть отдельная инструкция, работающая именно с этой парой регистров)
3. Вызовем инструкцию деления
```
movq  %rbx, %rax // 1
cqto // 2
idivq %rcx // 3
// теперь в %rdx лежит частное, в %rax - остаток.
```

В общем случае, размер делимого должен быть  в 2 раза больше размера делителя.  
Да, без поллитра не разберешься, но вы держитесь...

## Адресация
Понятно, что в регистре мы можем хранить либо какой-то адрес, либо просто какое-то значение.  
Поговорим о том, как с их помощью работать с памятью и об интересных языковых конструкциях, которые для этого существуют.

*Ниже мы считаем, что в `%rax` у нас лежит какой-то адрес*

*  `movq %rax, %rbx` - this does what you think it does. Просто копируем адрес из `%rax` в `%rbx`
*  `leaq %rax, %rbx` - в данном случае эквивалентно предыдущей команде
*  `movb (%rax), %bl` - уже веселее - `(%rax)` обозначает значение, лежащее по адресу, записанному в `%rax`, т.е. команда копирует один байт, лежащий по адресу из `%rax`, в `%bl`.
*  `leaq (%rax, %rcx), %rbx` - пусть в `%rax` у нас лежит адрес начала какого-то массива байтов `arr`, а в `%rcx` - некоторое число, которое мы считаем индексом в этом массиве (пусть будет `i`). Тогда эта команда записывает **адрес** `arr[i]` в `%rbx`. Это удобно в циклах - мы можем инициализировать `%rax` как адрес начала, а `%rcx` положить равным нулю, и если увеличивать `%rcx` на единицу на каждой итерации, на `i`м шаге команда выше положит в `%rbx` нужный нам адрес `arr[i]`.
* `movb (%rax, %rcx), %bl` - а вот эта команда уже записывает **значение** (один байт) по адресу `%rax + %rcx` в нижний байт регистра `%rbx` - `%bl`.

**Запомните:** `lea` записывает адрес, `mov` - значение! Исключение составляют первые два примера (в регистре и так лежит адрес).

#### Пара слов о регистре `%rip`
Это **registry instruction pointer**, который, формально говоря, в любой момент времени указывает на адрес следующей инструкции, которая будет выполнена процессором.  
Используется он только в одном случае - при обращении к глобальным переменным.

Вообще вы уже могли заметить, что  во всех примерах с переменными обращение к адресу было сделано не так:
```
var
```
, а так:
```
var(%rip)
```
Это нужно для соблюдения принципа *PIE* (position-independent execution), который на 64-битных архитектурах должен соблюдаться **всегда**.  
На самом деле, не парьтесь: просто достаточно запомнить, что к глобальным переменным мы **всегда** обращаемся через `%rip`, и называется это *относительная адресация*.  
В списке типов адресаций она не упомянута, потому особо и не нужна нигде, кроме обращения к глобальным переменным.

Хотите положить в регистр `%rdi` **адрес** глобальной переменной `n`? ~~Круто! Подняли трубку, набрали номер!~~  
Используйте `leaq n(%rip), %rdi`.

Хотите положить в регистр `%rdi` **значение** глобальной (восьмибайтной) переменной `n`? ~~Круто! Подняли трубку, набрали номер!~~  
Используйте `movq n(%rip), %rdi`.


## Стек
Стек предоставляет нам возможность хранения данных (или передачи их в функцию, но об этом позже).  
Для стека даже есть отдельный регистр - `%rsp` (*registry stack pointer*). Как можно догадаться из названия - значение этого регистра *всегда* равно адресу вершины стекка.

### Как класть в стек данные
Для этого есть команда `push src`, к которой тоже можно (и нужно!) дописывать суффикс b/w/l/q, соответствующий размеру операнда `src`.

После выполнения этой команды на вершине стека лежит "запушенное" значение, а `%rsp` **уменьшается** на размер этого значения (т.е. при добавлении данных в стек указатель на его вершину уменьшается - стек "растёт вниз").

### Как доставать из стека данные
Для этого есть команда `popq dest` (с суффиксами то же самое, что и в `popq`).  
Она копирует соответствующее суффиксу количество байт в `dest`, после чего удаляет эти байты из стека.

После выполнения этой команды `%rsp` **увеличивается** на количество взятых из стека байт.

Пример:
```
...
// Пусть мы хотим обменять значения двух четырехбайтных регистров: %eax и %ebx (таким вот странным способом)
pushl %eax // суффикс l - 4 байта
pushl %ebx

// теперь на вершине стека лежит %ebx, а чуть ниже - %eax

popl  %eax // теперь тут лежит значение %ebx
popl  %ebx // а тут - старое значение %eax
...
```

Еще момент: очередное соглашение, придуманное людьми, которым больше нечего делать, кроме как придумывать разные соглашения для архитектуры x86_64 - при вызове функции значение `%rsp` *должно быть* кратно 16 (после входа в `main` оно кратно лишь восьми).
Если вам не нужно перед вызовом функции класть в стек какой-то восьмибайтный регистр, то самый адекватный способ выполнить это условие - просто сдвинуть `%rsp` на 8 байт вниз (`subq $8, %rsp`).
Главное - после вызова очередной функции не забыть сдвинуть `%rsp` обратно на 8 байт вверх (`addq $8, %rsp`).

## Вызовы функций, метки
### Метки
Метка - некоторый именованный адрес, к которому вы можете прыгнуть в любой момент выполнения программы (можно сказать, что это в какой-то степени функция для бедных)  
Пример:
```
...
multiply_rax_by_two:
    imulq $2, %rax

main:
    movq $0, %rax
    jmp  multiply_rax_by_two // jmp - безусловный переход по указанному адресу
...
```

Так как `jmp` - просто прыжок к какому-то адресу, то после выполнения всех инструкций, "заключенных" под меткой, код будет просто выполняться дальше "сверху вниз" (в данном случае вообще пойдет ещё раз в main, поэтому `%rax` будет просто бесконечно умножаться на 2).  
Это наталкивает на мысль о том, что нам нужны какие-то условные операторы, и.. конечно, нужны, но о них поговорим чуть позже.

### Что вообще происходит, когда вы вызываете функцию
В целом, при вызове какой-то функции (прыжок к метке - **не** вызов функции), мы тоже прыгаем к адресу, по которому находится функция, но мы ещё должны знать, что нам делать, когда код функции выполнится.  
Для этого умные люди придумали такую механику этого процесса:
1. компилятор видит инструкцию `call %function_name%`
2. запоминает адрес следующей инструкции после этого вызова (на него указывает `%rip`)
3. кладёт этот адрес в стек
4. прыгает к адресу функции `%function_name%`
5. исполняет код функции
6. каждая функция **должна** завершаться ключевым словом `ret` - эта команда снимает адрес возврата с вершины стека и переходит по нему
7. ???
8. Profit!

Пример(починим наше умножение на 2, чтобы оно не было бесконечным):

```
...
multiply_rax_by_two:
    imulq $2, %rax
    ret // функция должна завершаться ключевым словом ret

main:
    movq $0, %rax
    call  multiply_rax_by_two // call - вызов функции
...
```
### Передача и сохранение данных при вызове функций
#### Передача аргументов
Функция, очевидно должна делать что-то с аргументами и что-то возвращать.  
Понятно, что аргументы должны лежать в регистрах, но в каких?

Да, как вы, возможно догадались, существует *ещё одно* соглашение о том, какие регистры и в каком порядке используются для передачи аргументов в функцию.
* `%rdi` - первый аргумент
* `%rsi` - второй аргумент
* `%rdx` - третий аргумент
* `%r10` - четвертый
* `%r9`  - пятый
* `%r8` - шестой  
Если их больше, остальные передаем через стек (но у меня даже до `%r10` ни в одной задаче из курса не доходило).

Помните, что если вы хотите передать аргументы на стеке, их нужно пушить в обратном порядке (если аргументов три, то сначала третий, потом второй, потом первый - тогда они будут лежать в том порядке, в котором их ожидает увидеть функция).

#### Возвращаемое значение функции
Если функция должна что-то возвращать, для этого обычно используют регистр `%rax`.

#### Сохранение значений регистров при вызове функции
Допустим, у вас в работе есть регистр `%rcx`, вы храните в нём счетчик цикла/дату следующего солнцестояния/шпаргалку по методам оптимизации/...  
Когда вы вызовете какую-то функцию, она внутри может использовать этот регистр в каких-то своих целях, в результате чего ваше значение просто потеряется (туда может быть записано что угодно).  
Самый простой и правильный способ - положить значение регистра в стек, а потом достать его оттуда, и ничего не потеряется:
```
...
// Допустим, мы хотим сохранить значения регистров %rbx и %rcx
pushq %rbx
pushq %rcx
call my_function
popq %rcx // достаем значения в обратном порядке
popq %rbx
...
```

#### Системные вызовы
Некоторые вещи мы не в состоянии реализовать самостоятельно (например, ввод и вывод данных) - нам требуется помощь ОС, с которой мы общаемся посредством системных вызовов.  
Системный вызов - это вызов некоторой функции, предоставляемой нам операционной системой.  
Производится он следующим образом:
1. в `%rax` кладётся номер системного вызова (0 для `read`, 1 для `write`, 60 для `exit`) и т.д.
2. в регистры `%rdi`, `%rsi`, `%rdx`, ..., кладутся аргументы для этой системной функции
3. пишется инструкция `syscall`  
Полную таблицу системных вызовов и их номеров можно найти [здесь](https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md) (помним, что наша архитектура - x86_64).
Функции ОС, которые мы таким образом вызываем, удовлетворяют всем соглашениям, упомянутым выше (аргументы туда передаются именно так, как было сказано в соответствующем параграфе, возвращают значение тоже через `%rax`).  
Пример:

```
...
section .data

buffer:
    .space 4, 0

section .text
...
main:
    // Хотим прочитать 4 байта (или столько, сколько дадут) в начало массива buffer
    movq $0, %rax // в $rax кладём 0 - номер вызова read
    movq $0, %rdi // первый аргумент read - файловый дескриптор (0 - stdin, 1 - stdout, 2 - stderr), читать хотим из stdin
    leaq buffer(%rip), %rsi // помним про относительную адресацию! второй аргумент read - адрес начала буфера для чтения
    movq $4, %rdx // третий аргумент - максимальное количество байт, которое мы готовы прочитать, т.е. 4
    
    // перед вызовом не забудьте запушить в стек регистры, которые вы боитесь потерять (если они есть)
    syscall // системный вызов

    // в %rax теперь лежит значение, которое вернула sys_read - количество прочитанных байтов
...
```

Вообще без системных вызовов мы никуда - хотя бы потому, что программа должна завершаться системным вызовом `exit`.

#### Вызовы функций стандартной библиотеки C
Коль уж мы пишем на GNU ассемблере, хочется как-то использовать сишную стандартную библиотеку - например, читать числа указанным выше способом не очень удобно (нужно реализовать аналог сишного `getchar`, потом перевести полученные символы в одно число, используя схему Горнера).

И так можно и нужно делать! Допустим, мы хотим прочитать из `stdin` один int в переменную `n`, а потом вывести его (да, это буквально первая задача в блоке и она уже разобрана, но всё же):
```
.section .rodata

scanf_format:
  .string "%d"

printf_format:
  .string "%d\n" // пусть будет ньюлайн в конце - нам не жалко

.section .data

n:
  .long 0 // наша переменная для чтения

.section .text
.globl  main
.type   main, @function

main:
  subq  $8, %rsp // поправляем стек перед системными вызовами (теперь %rsp кратен 16)
 
  movq $0, %rax // в %rax будет лежать возвращаемое значение scanf (0 если удалось прочитать, -1 если встречен конец файла)
  leaq  scan_format(%rip), %rdi // первый аргумент scanf - адрес форматной строки
  leaq  n(%rip), %rsi // второй аргумент scanf - адрес буфера (т.е. куда читать)
  call scanf // вызываем scanf
 
  movq $0, %rax // в %rax будет лежать возвращаемое значение printf (не помню, честно говоря, что он возвращает, но вроде бы может вернуть -1 при невалидной форматной строке)
  leaq  print_format(%rip), %rdi // первый аргумент printf - адрес форматной строки
  movl  n(%rip), %esi // второй аргумент printf - значение(!) для печати (именно поэтому mov, а не lea)
  call printf // вызываем printf

  mov  stdout(%rip), %rax // да, у stdout тоже есть адрес, и сейчас мы хотим вызвать системную функцию fclose, которая его закроет (на самом деле это необязательно, но в примере так рекомендуют делать)
  mov  %rax, %rdi
  call fclose

  addq $8, %rsp // восстанавливаем стек

  movq $60, %rax // код системного вызова exit
  movq  $0, %rdi // аргумент exit - код возврата (в нашем случае 0)
  syscall
```